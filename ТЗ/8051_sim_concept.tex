
\include{options}
\include{listing}


\begin{document}
\large

\include{titlepage}

\tableofcontents
\newpage


\section{Введение}
\subsection{Назначение}
Данный программный продукт может быть использован в качестве исполнителя программ, отладочного средства для программ под intel 8051, а также для демонстрации работы программ. В связи с тем, что микропроцессор 8051 был создан 1980 году, на данный момент трудно найти реальный работающий экземпляр, причём часто их цена сильно завышена.\\
Если требуется написать программу для этого процессора, то для её отладки лучше использовать симулятор. Он бесплатен, а также позволяет отслеживать порядок инструкций и состояние памяти.\\
\subsection{Краткий обзор}
Данная программа должна симулировать работу процессора intel 8051, а именно работу с памятью и исполнение инструкций. Физические интерфейсы микроконтроллера программа не отражает.\\
Пользователь составляет файл, отражающий состояние памяти устройства в начальный момент времени. Файл может быть либо бинарным (код программы), либо либо написанным в специальном текстовом формате, который описан ниже. В текстовом формате также можно использовать дополнительные ключевые слова для отладки.\\
Симулятор должен исполнять программы в соответствии со спецификацией процессора 8051, то есть выполнять над виртуальной памятью и регистрами те же действия, которые заявлены у реального процессора, и в такой же последовательности. \\
Скорость выполнения программы может отличаться от скорости реального процессора в большую или меньшую сторону, на это ограничений не накладывается.
При желании скорость обработки инструкций можно замедлить при помощи аргументов командной строки. \\
Также данный симулятор должен поддерживать возможность передать необходимые параметры (не для отладки) только через аргументы командной строки, чтобы облегчить работу с симулятором других программ и сценариев.
\section{Описание}

\subsection{Система команд процессора}
Набор инструкций, которые может обрабатывать симулятор, должен соответсововать тому набору инструкций, которыми оперирует реальный процессор intel 8051.\\
Описание всех инструкций, регисторв и поведения процессора приведено в книге \\[5mm]
Горюнов А.Г., Ливенцов С.Н. Архитектура микроконтроллера Intel 8051 \\
Томск: Изд-во ТПУ, 2005. - 86 с. \\

\subsection{Взаимодействие с пользователем}
Эта программа имеет консольный интерфейс и запускается из командной строки с необходимыми аргументами.\\
~\\
Использование:
[имя программы] [параметры] [имя входного файла] \\

{\bf Параметры:}
\begin{enumerate}
	\item[{\tt\large -h}] {-}-help \\
	Показать краткую справку по командам симулятора.\\
	
	\item[{\tt\large -d}] {-}-debug \\
	Включает отладочные средства (реакцию на брэйкпойнты, вывод в консоль).
	Если флаг не  установлен, то симулятор исполняет программу, ничего не выводя в консоль.
	
	\item[{\tt\large -o}] {-}-out \\
	Имя выходного файла. \\ 
	Так будет называться файл образа памяти, полученный после завершения программы.\\
	Также с этой строки будут начинаться имена промежуточных выходных файлов, выводимых в процессе работы программы. Имя файла по-умолчанию -- "memory".\\
	Пример: -o myfile
	
	\item[{\tt\large -c}] {-}-clk \\
	Время задержки между исполнением инструкций. Количество милисекунд, целое беззнаковое число. По умолчанию задержки нет.\\
	В процессе работы пользователь может нажать клавишу Enter, тем самым приостановив программу.
	Пример: -c 1000
	
	\item[{\tt\large -v}] {-}-verbose \\
	Verbose режим. Отображает в реальном времени последовательность машинных команд, которые исполняет процессор. По умолчанию выключен.
	
	\item[{\tt\large -s}] {-}-step \\
	Step-by-step режим. Позволяет исполнять инструкции по-одной, нажимая клавишу Enter. Если перед нажатием Enter указать число (десятичное целое беззнаковое), то симулятор автоматически исполнит указанное количество инструкций. По умолчанию выключен.
	
	\item[{\tt\large -m}] {-}-mode \\
	Тип принимаемого на вход файла (bin или text) \\
	Пример: -m bin
	
	\item[{\tt\large -b}] {-}-break \\
	Добавление брэйкпойнтов \\
	С этим параметром передаётся строка, содержащая адреса в шестнадцатеричном формате, разделённые пробелами. На каждом из этих адресов будет добавлен брэйкпойнт. \\
	Пример: -b "5 A 2C DD"
	
	\item[{\tt\large -z}]
	Имя выходного бинарного файла.
	С этим параметром симулятор не исполняет программу, а просто преобразует входной текстовый файл в бинарный файл - образ памяти.\\
	Пример: -z myfile.bin
\end{enumerate}

\subsection{Текстовый формат ввода программы}
Снимок состояния микроконтроллера i8051 \\ представляет собой JSON-структуру вида:\\
\begin{lstlisting}
{
	"registers": {
	"rga": 0,
	"rgb": 0,
	"rgc": 0,
	...
	}
	"program": "...",
	"data": "...",
	
}
\end{lstlisting}
Состояние памяти программы (program) и памяти данных (data) задаётся в специальном текстовом формате.
Байты памяти идут по порядку. Пробелы, табуляция и переносы строки используются в качестве разделителя.

\paragraph{Числа и инструкции в памяти}~\\
Обычное число (8 двоичных разрядов) может быть записано в виде:
~
~\\[3mm]
\begin{tabular}{{l}{l}}
	Шестнадцатеричного числа: & {\tt\large \#FF} \\[2mm]
	Двоичного числа:          & {\tt\large 11111111} \\[2mm]
	Десятичного числа:        & {\tt\large *255} \\
\end{tabular} \\[3mm]
~
Числа должны быть целыми и неотрицательными. Если симулятор прочтёт число больше 255, то программа завершится с ошибкой.\\
~\\
Также пользователь может писать названия инструкций и регистров латинскими буквами. Инструкции разделяются пробелами, символами табуляции или переносом строки. Регистр букв не учитывается.\\

\paragraph{Брэйкпойнты}~\\
В текстовое представление можно добавлять точки останова программы (breakpoint). Когда программа доходит до брэйкпойнта, то приостанавливается и задаёт пользователю вопрос, продолжать выполнение программы, или же завершить её.\\
Также после остановки программы на брэйкпойнте пользователь может сохранить состояние процессора в файл, нажав клавишу \textbf{S}. \\
Брэйкпойнт записывается в формате $\wedge$BREAK или \_BREAK \\
Символ $\wedge$ ставится перед BREAK, если программа должна быть приостановлена после предыдущей инструкции, а символ \_ ставится, если программа должна быть приостановлена перед следующей инструкцией.

\paragraph{Точки сохранения снимка памяти}~\\
Можно добавлять в код точки сохранения (savepoint). Когда программа доходит до сейвпойнта, то дампит в бинарный файл состояние памяти и регистров в данный момент.\\
Сейвпойнт записывается в формате $\wedge$SAVE или \_SAVE \\
Символы $\wedge$ и \_ выполняют ту же функцию, что и в случае с брэйкпойнтами. \\

{ \it \large
Брэйкпойнты и сейвпойнты не влияют на последовательность инструкций, которую в итоге исполняет процессор. Симулятор держит их в памяти отдельно и отслеживает, когда то или иное правило должно сработать.
}
\\

\paragraph{Комментарии}~\\
Пользователь может включать в текст программы комментарии, которые будут проигнорированы симулятором, но сделают код более понятным. Они записываются в двойных кавычках ("\space"). Комментарий может содержать любые символы кроме двойных кавычек.
Они будут проигнорированы на этапе перевода текста в бинарный код и никак не повлияют на программу.

\end{document}
